import asyncio
import os

from . import bencode


KRPC_MESSAGE_TYPE_QUERY = b'q'
KRPC_MESSAGE_TYPE_RESPONSE = b'r'
KRPC_MESSAGE_TYPE_ERROR = b'e'

KRPC_TRANSACTION_ID_KEY = b't'
KRPC_MESSAGE_TYPE_KEY = b'y'
KRPC_ARGUMENTS_KEY = b'a'
KRPC_ERROR_KEY = KRPC_MESSAGE_TYPE_ERROR
KRPC_RESPONSE_KEY = KRPC_MESSAGE_TYPE_RESPONSE
KRPC_QUERY_KEY = KRPC_MESSAGE_TYPE_QUERY


def generate_transaction_id():
    return os.urandom(2)


class KRPCError(Exception):

    code = None

    message = None

    def __init__(self, code, message):
        self.code = code
        self.message = message

        super(KRPCError, self).__init__()


class GenericError(KRPCError):

    def __init__(self):
        super(GenericError, self).__init__(201, 'Generic Error')


class ServerError(KRPCError):

    def __init__(self):
        super(ServerError, self).__init__(202, 'Server Error')


class ProtocolError(KRPCError):

    def __init__(self):
        super(ProtocolError, self).__init__(203, 'Protocol Error')


class MethodUnknown(KRPCError):

    def __init__(self):
        super(MethodUnknown, self).__init__(204, 'Method Unknown')


class KRPCProtocol(asyncio.DatagramProtocol):
    """
    The KRPC protocol is a simple RPC mechanism consisting of bencoded dictionaries sent over UDP.
    A single query packet is sent out and a single packet is sent in response. There is no retry.

    There are three message types: query, response, and error.

    A KRPC message is a single dictionary with two keys common to every message and additional keys depending on the
    type of message.
    Every message has a key "t" with a string value representing a transaction ID.
    This transaction ID is generated by the querying node and is echoed in the response, so responses may be correlated
    with multiple queries to the same node.
    The transaction ID should be encoded as a short string of binary numbers, typically 2 characters are enough as they
    cover 2^16 outstanding queries.
    The other key contained in every KRPC message is "y" with a single character value describing the type of message.
    The value of the "y" key is one of "q" for query, "r" for response, or "e" for error.
    """

    transport = None

    loop = None

    _pending_queries = None

    def __init__(self, *, loop=None):
        if loop is None:
            loop = asyncio.get_event_loop()

        self.loop = loop
        self._pending_queries = {}

    def connection_made(self, transport):
        self.transport = transport

    def handle_query(self, message):
        query_method = message.get(KRPC_MESSAGE_TYPE_QUERY)

        method = getattr(self, 'on_%s' % query_method.decode('utf-8'), None)

        if method:
            arguments = message.get(KRPC_ARGUMENTS_KEY, None)

            if arguments is not None:
                try:
                    return method(
                        **{kw.decode('utf-8'): v for (kw, v) in arguments.items()}
                    )
                except TypeError:
                    raise ProtocolError
                except:
                    # TODO: Maybe log here?
                    raise ServerError
            else:
                raise ProtocolError
        else:
            raise MethodUnknown

    def datagram_received(self, data, addr):
        message = bencode.decode(data)

        assert isinstance(message, dict)

        message_type = message.get(KRPC_MESSAGE_TYPE_KEY)

        transaction_id = message.get(KRPC_TRANSACTION_ID_KEY)

        if message_type == KRPC_MESSAGE_TYPE_QUERY:
            response = {
                KRPC_TRANSACTION_ID_KEY: transaction_id,
            }

            try:
                response.update({
                    KRPC_MESSAGE_TYPE_KEY: KRPC_MESSAGE_TYPE_RESPONSE,
                    KRPC_RESPONSE_KEY: self.handle_query(message)
                })
            except KRPCError as error:
                response.update({
                    KRPC_MESSAGE_TYPE_KEY: KRPC_MESSAGE_TYPE_ERROR,
                    KRPC_ERROR_KEY: [error.code, error.message.encode('utf-8')]
                })

            data = bencode.encode(response)

            self.transport.sendto(data, addr)

        else:
            pending_query = self._pending_queries.pop(transaction_id, None)

            if pending_query:
                if message_type == KRPC_MESSAGE_TYPE_RESPONSE:
                    pending_query.set_result(message.get(b'r'))
                elif message_type == KRPC_MESSAGE_TYPE_ERROR:
                    error_code, error_description = message.get(b'e')

                    error = KRPCError(error_code, error_description)
                    pending_query.set_exception(error)

    async def query(self, addr, method, *, timeout=5, **kwargs):
        transaction_id = generate_transaction_id()

        query = {
            KRPC_TRANSACTION_ID_KEY: transaction_id,
            KRPC_MESSAGE_TYPE_KEY: KRPC_MESSAGE_TYPE_QUERY,
            b'q': method,
            b'a': {a.encode('utf-8'): b for (a, b) in kwargs.items()}
        }

        message = bencode.encode(query)

        response = asyncio.Future(loop=self.loop)

        self._pending_queries[transaction_id] = response
        self.transport.sendto(message, addr=addr)

        result = await asyncio.wait_for(response, timeout, loop=self.loop)

        return result